<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>CoActionOS</title>
        <description>CoActionOS - CoActionOS, Inc</description>
        <link>http://Coactionos.github.io</link>
        <link>http://Coactionos.github.io</link>
        <lastBuildDate>2013-12-20T22:46:15-07:00</lastBuildDate>
        <pubDate>2013-12-20T22:46:15-07:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Hello World</title>
                <description>&lt;p&gt;Programming tutorials, as you will notice, always begin with the quintessential “Hello World” program which demonstrates: how to use compilers, the basic usage of the language, and how to use output–essential for seeing if your program is working correctly. The code below is the standard C Hello World program.&lt;/p&gt;
&lt;div class=&#39;highlight&#39;&gt;&lt;pre&gt;&lt;code class=&#39;cpp&#39;&gt;&lt;span class=&#39;c1&#39;&gt;//include is a compiler directive and .h refers to a header file&lt;/span&gt;
&lt;span class=&#39;cp&#39;&gt;#include &amp;lt;stdio.h&amp;gt; &lt;/span&gt;&lt;span class=&#39;c1&#39;&gt;//contains the prototype for printf&lt;/span&gt;
&lt;span class=&#39;cp&#39;&gt;#include &amp;lt;stdlib.h&amp;gt; &lt;/span&gt;&lt;span class=&#39;c1&#39;&gt;//contains the prototype for exit&lt;/span&gt;

&lt;span class=&#39;c1&#39;&gt;//main is the symbol that the OS looks for to enter the program&lt;/span&gt;
&lt;span class=&#39;kt&#39;&gt;int&lt;/span&gt; &lt;span class=&#39;nf&#39;&gt;main&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;(&lt;/span&gt;&lt;span class=&#39;kt&#39;&gt;int&lt;/span&gt; &lt;span class=&#39;n&#39;&gt;argc&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;,&lt;/span&gt; &lt;span class=&#39;kt&#39;&gt;char&lt;/span&gt; &lt;span class=&#39;o&#39;&gt;*&lt;/span&gt; &lt;span class=&#39;n&#39;&gt;argv&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;[]){&lt;/span&gt;  
     &lt;span class=&#39;n&#39;&gt;printf&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;(&lt;/span&gt;&lt;span class=&#39;s&#39;&gt;&amp;quot;Hello World&lt;/span&gt;&lt;span class=&#39;se&#39;&gt;\n&lt;/span&gt;&lt;span class=&#39;s&#39;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;);&lt;/span&gt; &lt;span class=&#39;c1&#39;&gt;//printf is part of stdio&lt;/span&gt;
     &lt;span class=&#39;n&#39;&gt;exit&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;(&lt;/span&gt;&lt;span class=&#39;mi&#39;&gt;0&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;);&lt;/span&gt;
&lt;span class=&#39;p&#39;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#39;alert alert-info&#39;&gt;&lt;span class=&#39;label label-danger&#39;&gt;Note&lt;/span&gt; The program above also exposes preprocessor directives, 
raw data types, as well as pointers and arrays. These principles are discussed 
in later lessons. &lt;/div&gt;
&lt;p&gt;The program has the following output.&lt;/p&gt;
&lt;pre&gt;Hello World&lt;/pre&gt;
&lt;h3 id=&quot;compiling_hello_world&quot;&gt;Compiling Hello World&lt;/h3&gt;

&lt;p&gt;The compiler is a software program that converts C code into an executable program. Most embedded systems use cross-compilers meaning that the operating system used to compile the code is not the same as the operating system used to run the code. CoActionOS uses a cross-compiler on Mac OS X or Windows to create programs that run on embedded hardware (this tutorial has the details for doing that).&lt;/p&gt;

&lt;p&gt;Using the word compiler is a simplification of what is actually happening. “Compiling” is a multi-step process that starts with C files and produces executable files or libraries. The compiler converts the C code (text) to object code. The object code is then either converted to a library using an archiver program or an executable using a linker program.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#39;post_image&#39; src=&#39;/images/compiler-library-flow.svg&#39; /&gt;&lt;/p&gt;

&lt;p&gt;Process Flow for Creating Libraries&lt;/p&gt;

&lt;p&gt;A library is a collection of object code files that is purposed for many different executables. For example, a library may contain code that computes a generic cosine. The library can then be used in executables that use a cosine calculation in various applications.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#39;post_image&#39; src=&#39;/images/compiler-executable-flow.svg&#39; /&gt;&lt;/p&gt;

&lt;p&gt;Process Flow for Creating Embedded Binary Files&lt;/p&gt;

&lt;p&gt;Libraries and object files are linked together to create an executable image. For desktop systems, this is the end of the process. However, most embedded systems require the executable image be translated to either a binary or hex file so that it can be loaded in embedded RAM or flash memory.&lt;/p&gt;

&lt;p&gt;The compiler is typically a command-line based program, but most developers use an integrated development environment (IDE) to both edit the code as well as compile and run programs. Eclipse is one popular, free IDE that includes C/C++ development tools. Eclipse is great for use with CoActionOS.&lt;/p&gt;

&lt;h3 id=&quot;program_structure&quot;&gt;Program Structure&lt;/h3&gt;

&lt;p&gt;The Hello World program introduces the modular programming structure of the C language. Programs consist of functions and data which are either native to the program or part of another module packaged in a library. The Hello World program does not declare any data and has just a single function, main(), which uses printf() and exit() which are part of separate modules from the C Standard library. The OS that runs the program uses main() as the entry point which is standard for C programming. In the example above, main() is declared with two parameters argc and argv which is the norm for desktop operating systems. For some embedded systems, main() may be declared more simply (see below) because only one program is ever installed on the system and no parameters are passed to main().&lt;/p&gt;
&lt;div class=&#39;highlight&#39;&gt;&lt;pre&gt;&lt;code class=&#39;cpp&#39;&gt;&lt;span class=&#39;c1&#39;&gt;//OS doesn&amp;#39;t pass any arguments to main(), int is returned&lt;/span&gt;
&lt;span class=&#39;kt&#39;&gt;int&lt;/span&gt; &lt;span class=&#39;nf&#39;&gt;main&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;(&lt;/span&gt;&lt;span class=&#39;kt&#39;&gt;void&lt;/span&gt;&lt;span class=&#39;p&#39;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Before running main(), the OS runs startup code referred to as the C-runtime (CRT) code which initializes the program. The program then executes statements–separated by semi-colons–sequentially meaning printf() is first executed then exit() is executed.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#39;post_image&#39; src=&#39;/images/hello-flow.svg&#39; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;standard_output&quot;&gt;Standard Output&lt;/h2&gt;

&lt;p&gt;Hello World uses the printf() function from the stdio module. The stdio, or standard input/output, module includes functions and data useful for inputting data to the program (from the keyboard for example) and outputting data to the user (such as through a console or terminal program). Specifically, printf() writes a formatted string to the standard output. The OS determines what the standard output is. On a desktop computer, it is a console or terminal program. On an embedded system, printf() may output data to a UART serial port or over the USB–the default action for CoActionOS.&lt;/p&gt;

&lt;h2 id=&quot;take_away&quot;&gt;Take Away&lt;/h2&gt;

&lt;p&gt;The important things to learn here are that C is a modular programming language consisting of functions and data; the OS entry point for a C program is the main() function; the basic function used for text output is printf() which is used extensively in C during development for debugging.&lt;/p&gt;</description>
                <link>http://Coactionos.github.io/c-tutorial/2013/12/20/Embedded-C-Tutorial-Hello-World</link>
                <guid>http://Coactionos.github.io/c-tutorial/2013/12/20/Embedded-C-Tutorial-Hello-World</guid>
                <pubDate>2013-12-20T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Using Op Amps in Embedded Design</title>
                <description>&lt;p&gt;Op-amps are very useful devices in electronics and can be very helpful when interfacing analog and digital technologies in embedded systems. &lt;img src=&quot;/images/inverting-opamp.png&quot; alt=&quot;Inverting Op Amp&quot; title=&quot;Inverting Op Amp&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction_to_opamps&quot;&gt;Introduction to Op-Amps&lt;/h2&gt;

&lt;p&gt;An op-amp (or operational amplifier) is a very common electrical circuit widely used in the electronics industry. It has two inputs (plus and minus) as well as one output. Traditional op-amps require a positive and negative voltage supply (e.g. plus and minus 15V) and the output voltage is limited to within about a volt of each rail–meaning the maximum output for an op-amp with a 15V supply is around 14V. This presents a problem in single supply systems with traditional digital voltage levels. Traditional op-amps are not able to take advantage of the full range of ADCs nor definitively drive digital inputs. The rail problem is overcome by using rail-to-rail op-amps which are designed for single supply operation and can drive its output within a few millivolts of the power rails. Rail-to-rail op-amps are particularly well suited for embedded systems integration. Before looking at some typical applications, it is important to understand how to analyze an op-amp circuits.&lt;/p&gt;

&lt;h2 id=&quot;analyzing_opamp_circuits&quot;&gt;Analyzing Op-amp Circuits&lt;/h2&gt;

&lt;p&gt;Ideal op-amps are a good first order approximation of op-amp behavior and are used to analyze as well as design op-amp circuits. The ideal op-amp has two basic rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Infinite Input Impedance (no current flows in or out of the input terminals)&lt;/li&gt;

&lt;li&gt;Output forces voltage difference on inputs to zero in closed-loop designs (meaning the voltage at both input terminals is the same)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To apply these two rules to op-amp circuit analysis, it is important to be familiar with two electrical laws: Ohm’s Law and Kirchhoff’s Current Law. Ohm’s law is defined by the equation:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#39;post_equation&#39; src=&#39;/images/ohms-law.svg&#39; /&gt;&lt;/p&gt;

&lt;p&gt;That is, voltage is equal to current times resistance. Ohm’s law can be used to calculate the current through the resistor in the diagram below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ohms-law-circuit.png&quot; alt=&quot;Ohms Law Circuit&quot; title=&quot;Ohm&#39;s Law Circuit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kirchhoff’s current law states that the sum of all currents entering a node is zero. The law implies that all currents entering the node are equal to the currents leaving the node. This law can be applied to the op-amp circuit above (first in the article).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opamp-kirchhoff-0.svg&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If Ohm’s law is combined with Kirchhoff’s current law, the equation then becomes the following.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opamp-kirchhoff-1.svg&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The equation is simplified further by applying the rules of an ideal op-am. First, infinite input impedance means that the current, &lt;em&gt;&lt;em&gt;i&lt;/em&gt;&lt;/em&gt; ~3~ is zero. Second, the voltage difference on the inputs is zero means &lt;em&gt;&lt;em&gt;V&lt;/em&gt;&lt;/em&gt; ~&lt;em&gt;n&lt;/em&gt;~ = &lt;em&gt;&lt;em&gt;V&lt;/em&gt;&lt;/em&gt; ~p~ = &lt;em&gt;&lt;em&gt;0V&lt;/em&gt;&lt;/em&gt;. The resulting equation is as follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opamp-kirchhoff-2.svg&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To calculate the gain of the circuit, the above equation is solved for the output divided by the input.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opamp-kirchhoff-3.svg&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The op-amp circuit shown above is called an inverting amplifier (the output is the input times a negative number). As drawn, the inverting amplifier is not well adapted to single supply embedded systems because the output is centered at 0V. However, there are plenty of great ways to use op-amps in single supply, embedded designs.&lt;/p&gt;

&lt;h2 id=&quot;using_opamps_in_embedded_systems&quot;&gt;Using Op-amps in Embedded Systems&lt;/h2&gt;

&lt;p&gt;Op-amps are great in embedded systems when mixing analog and digital circuitry. One common use is signal conditioning before sampling with an analog-to-digital converter (ADC). The op-amp can also be used as a comparator for comparing thresholds or as a frequency counter.&lt;/p&gt;

&lt;h2 id=&quot;signal_conditioning_example&quot;&gt;Signal Conditioning Example&lt;/h2&gt;

&lt;p&gt;A pressure sensor typically has an output in the millivolt range. To measure this voltage with an ADC on a microcontroller, an op-amp is used to scale the output of the pressure sensor to span the range of the ADC input. For example, if the pressure sensor output is zero volts to 250mV and the ADC input range is zero to 2.5V, the amplifier needs to magnify the sensor output with a gain of 10. Because all the voltages are positive, the desired op-amp configuration is a non-inverting op-amp.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/non-inverting-opamp.png&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The analysis technique described above shows that the output of the op-amp is:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opamp-kirchhoff-4.svg&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the feedback resistor is 9KOhms and the input resistor is 1KOhms, the gain will be 10 such that the output of the pressure sensor will be scaled to take advantage of the full range of the ADC.&lt;/p&gt;

&lt;h2 id=&quot;frequency_counter_example&quot;&gt;Frequency Counter Example&lt;/h2&gt;

&lt;p&gt;Another useful application of the op-amp is a sine-wave to square-wave converter which can be input to a timer clock input to measure frequency. For example, if you have a sine wave in your embedded application and want to measure the frequency, you can pass the wave through an op-amp and use a timer on the microcontroller to count rising edges. Converting the rising edges to frequency can be done in one of two ways. The fast way is to count the number of MCU clock cycles between rising edges; this method works well if the MCU clock speed is much higher have the input frequency. The slow way is to count the number of rising edges in a given period of time. Either method uses the circuit below to convert the sine wave to a square wave that can act as the timer input.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/freq-counter-circuit.png&quot; alt=&quot;Kirchoff Current Law&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first stage of the circuit adjusts the sine wave to be centered around Vcc/2. Rf and Ri can be adjusted so that the output swing of the first amplifier is between 0V and Vcc. The second op-amp acts as a voltage comparator. If the input (on the inverting terminal) is greater than Vcc/2 (the non-inverting terminal), the output is zero volts. If the inverting input is less than Vcc/2, the output is Vcc assuming the op-amp is of the rail-to-rail variety.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Op-amps are great for analog signals in digital designs (especially rail-to-rail op-amps). The ideal op-amp as well as knowledge of basic electrical principles greatly simplify designing and integrating op-amps in your embedded designs.&lt;/p&gt;</description>
                <link>http://Coactionos.github.io/embedded/2013/12/14/Using-Op-Amps-in-Embedded-Design</link>
                <guid>http://Coactionos.github.io/embedded/2013/12/14/Using-Op-Amps-in-Embedded-Design</guid>
                <pubDate>2013-12-14T00:00:00-07:00</pubDate>
        </item>

        <item>
                <title>Controlling a Solenoid</title>
                <description>&lt;p&gt;&lt;img class=&#39;post_image&#39; src=&#39;/images/solenoid-ckt.png&#39; /&gt;&lt;/p&gt;

&lt;p&gt;Many products use solenoids to open and close valves. A microcontroller can control solenoids programmatically using a GPIO pin and a simple circuit.&lt;/p&gt;

&lt;h2 id=&quot;circuit&quot;&gt;Circuit&lt;/h2&gt;

&lt;p&gt;A solenoid can be enabled using a simple transistor circuit and a microcontroller. The circuit above shows a solenoid, MOSFET transistor, diode, and a microcontroller GPIO signal. To activate the solenoid, the microcontroller GPIO signal goes high causing the MOSFET to turn on. When on, the MOSFET allows current to flow from the power supply through the solenoid and to ground. The voltage rating for the solenoid dictates the voltage of the power supply (it is OK if the power supply voltage is different from the microcontroller voltage). The MOSFET should be selected to handle sufficient current to activate the solenoid as specified in the solenoid’s datasheet.&lt;/p&gt;

&lt;p&gt;Because the solenoid is an inductive device, the diode is added to protect the MOSFET. When the solenoid turns off, the current through the solenoid rapidly drops from the nominal value to zero. Since the voltage drop across the solenoid is proportional to the change in current (see equation below), the current drop creates a voltage spike which can damage the MOSFET. The diode prevents the voltage spike from reaching damaging levels by directing the current back to the power supply.&lt;/p&gt;

&lt;p&gt;!formula1.png!&lt;/p&gt;

&lt;h2 id=&quot;firmware_considerations&quot;&gt;Firmware Considerations&lt;/h2&gt;

&lt;p&gt;Controlling the solenoid in firmware is a straightforward operation with one exception. As mentioned, driving the GPIO high will turn the solenoid on, while driving it low will turn it off. However, there is a small amount of time while the microcontroller starts up where the solenoid may open unexpectedly. For example, if the default GPIO configuration is to have an internal pull-up activated, the solenoid will be activated while the microcontroller is starting u To avoid this behavior, an external pull-down resistor can be added to the GPIO line (shown below) to ensure the solenoid stays off during microcontroller initialization.&lt;/p&gt;

&lt;p&gt;!{width:40%}solenoid-pulldown-ckt.png!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;p. Controlling solenoids with microcontrollers is simple. Remember to ensure the MOSFET has sufficient current capability to activate the solenoid, include the protection diode to prevent the solenoid from damaging the MOSFET, and include a pull-down resistor on the GPIO line if the microcontroller doesn’t drive the line low at startup.&lt;/p&gt;</description>
                <link>http://Coactionos.github.io/embedded/2013/12/14/Controlling-a-Solenoid</link>
                <guid>http://Coactionos.github.io/embedded/2013/12/14/Controlling-a-Solenoid</guid>
                <pubDate>2013-12-14T00:00:00-07:00</pubDate>
        </item>


</channel>
</rss>
